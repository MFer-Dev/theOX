/* eslint-disable no-console */
/**
 * OX Read Replay Harness
 *
 * Proves that projections are deterministic and replay-safe:
 * 1. Seeds deterministic test data (agents + physics events)
 * 2. Snapshots row counts + checksums for projection tables
 * 3. Truncates projection tables (not consumer offsets)
 * 4. Resets consumer offset to earliest for all topics
 * 5. Re-materializes projections by re-running consumers
 * 6. Re-checks that counts + checksums match exactly
 *
 * Environment Variables:
 *   REPLAY_INCLUDE_NONDETERMINISTIC=1  Include nondeterministic tables in comparison
 *   REPLAY_SKIP_SEED=1                 Skip seeding step (use existing data)
 *   OX_REPLAY_JSON_OUTPUT=1            Output JSON result at end
 *
 * Run: pnpm exec tsx scripts/replay/ox_read_replay.ts
 */

import { Pool } from 'pg';
import { Kafka, logLevel, Admin } from 'kafkajs';
import { createHash } from 'crypto';

const env = (key: string, fallback: string) => process.env[key] || fallback;

const DATABASE_URL = env(
  'DATABASE_URL',
  `postgresql://${env('POSTGRES_USER', 'genme_local')}:${env('POSTGRES_PASSWORD', 'genme_local_password')}@${env('POSTGRES_HOST', 'localhost')}:${env('POSTGRES_PORT', '5433')}/${env('POSTGRES_DB', 'genme_local')}`
);

const REDPANDA_BROKERS = env('REDPANDA_BROKERS', 'localhost:9092').split(',');
const OX_READ_URL = env('OX_READ_URL', 'http://localhost:4018');
const AGENTS_URL = env('AGENTS_URL', 'http://localhost:4017');
const PHYSICS_URL = env('PHYSICS_URL', 'http://localhost:4019');

// Configuration: Include nondeterministic tables in comparison
const INCLUDE_NONDETERMINISTIC = process.env.REPLAY_INCLUDE_NONDETERMINISTIC === '1';
const SKIP_SEED = process.env.REPLAY_SKIP_SEED === '1';

// Consumer groups to reset
const CONSUMER_GROUPS = [
  'ox-read-materializer',        // events.agents.v1
  'ox-read-physics-materializer', // events.ox-physics.v1
] as const;

// Topics to replay
const TOPICS = [
  'events.agents.v1',
  'events.ox-physics.v1',
] as const;

// DETERMINISTIC tables: event-sourced, must match after replay
const DETERMINISTIC_TABLES = [
  // Core projections (from events.agents.v1)
  'ox_live_events',
  'ox_sessions',
  'ox_session_events',
  'ox_agent_patterns',
  'ox_artifacts',
  'ox_artifact_implications',
  'ox_capacity_timeline',
  'ox_environment_states',
  'ox_environment_history',
  'ox_environment_rejections',
  'ox_agent_deployment_patterns',
  'ox_deployment_drift',
  'ox_system_snapshots',
  // Phase 6 world state (from events.ox-physics.v1)
  'ox_world_state',
  'ox_world_state_history',
  'ox_world_effects_5m',
] as const;

// NONDETERMINISTIC tables: NOT event-sourced, depend on HTTP requests
// Excluded from comparison by default (override with REPLAY_INCLUDE_NONDETERMINISTIC=1)
const NONDETERMINISTIC_TABLES = [
  'observer_access_log', // Generated by HTTP requests, not Kafka events
  'ox_observers',        // Self-registration via HTTP, not event-sourced
] as const;

// Tables that should NOT be truncated (state tracking)
const PRESERVE_TABLES = ['consumer_offsets'] as const;

// Primary keys for each table (for deterministic checksum ordering)
const TABLE_PRIMARY_KEYS: Record<string, string[]> = {
  ox_live_events: ['id'],
  ox_sessions: ['session_id'],
  ox_session_events: ['id'],
  ox_agent_patterns: ['id'],
  ox_artifacts: ['id'],
  ox_artifact_implications: ['id'],
  ox_capacity_timeline: ['id'],
  ox_environment_states: ['deployment_target'],
  ox_environment_history: ['id'],
  ox_environment_rejections: ['id'],
  ox_agent_deployment_patterns: ['id'],
  ox_deployment_drift: ['id'],
  ox_system_snapshots: ['id'],
  ox_world_state: ['deployment_target'],
  ox_world_state_history: ['id'],
  ox_world_effects_5m: ['bucket_start', 'deployment_target'],
  observer_access_log: ['id'],
  ox_observers: ['observer_id'],
};

interface TableSnapshot {
  table: string;
  count: number;
  checksum: string | null;
  deterministic: boolean;
}

interface ReplaySummary {
  compared_tables: string[];
  excluded_tables: string[];
  topics_replayed: string[];
  consumer_groups_reset: string[];
  pass: boolean;
  diffs: Array<{ table: string; before: number; after: number; checksum_match: boolean }>;
  duration_ms: number;
}

const pool = new Pool({ connectionString: DATABASE_URL });

/**
 * Compute a deterministic checksum for a table.
 * Strategy: sha256 of concatenated sha256(row_json) sorted by primary key.
 */
async function computeTableChecksum(table: string): Promise<string | null> {
  const pk = TABLE_PRIMARY_KEYS[table];
  if (!pk) return null;

  try {
    // Get all columns except any volatile ones
    const columnsRes = await pool.query(
      `SELECT column_name FROM information_schema.columns
       WHERE table_name = $1 AND table_schema = 'public'
       ORDER BY ordinal_position`,
      [table]
    );

    const columns = columnsRes.rows.map(r => r.column_name);
    if (columns.length === 0) return null;

    // Build ORDER BY clause from primary key
    const orderBy = pk.join(', ');

    // Get all rows as JSON, ordered by PK
    const rowsRes = await pool.query(
      `SELECT row_to_json(t.*) as row_json FROM ${table} t ORDER BY ${orderBy}`
    );

    if (rowsRes.rows.length === 0) {
      return 'empty';
    }

    // Compute checksum: sha256 of concatenated row hashes
    const hash = createHash('sha256');
    for (const row of rowsRes.rows) {
      const rowHash = createHash('sha256')
        .update(JSON.stringify(row.row_json))
        .digest('hex');
      hash.update(rowHash);
    }

    return hash.digest('hex').substring(0, 16); // First 16 chars for brevity
  } catch (err) {
    console.log(`  [WARN] Could not compute checksum for ${table}: ${(err as Error).message}`);
    return null;
  }
}

async function getTableSnapshot(table: string, deterministic: boolean): Promise<TableSnapshot> {
  const countRes = await pool.query(`SELECT count(*) as count FROM ${table}`);
  const count = Number(countRes.rows[0].count);
  const checksum = await computeTableChecksum(table);

  return { table, count, checksum, deterministic };
}

async function snapshotAllTables(): Promise<TableSnapshot[]> {
  const snapshots: TableSnapshot[] = [];

  // Snapshot deterministic tables
  for (const table of DETERMINISTIC_TABLES) {
    try {
      const snapshot = await getTableSnapshot(table, true);
      snapshots.push(snapshot);
    } catch (err) {
      console.log(`  [WARN] Could not snapshot ${table}: ${(err as Error).message}`);
      snapshots.push({ table, count: -1, checksum: null, deterministic: true });
    }
  }

  // Snapshot nondeterministic tables (if included)
  if (INCLUDE_NONDETERMINISTIC) {
    for (const table of NONDETERMINISTIC_TABLES) {
      try {
        const snapshot = await getTableSnapshot(table, false);
        snapshots.push(snapshot);
      } catch (err) {
        console.log(`  [WARN] Could not snapshot ${table}: ${(err as Error).message}`);
        snapshots.push({ table, count: -1, checksum: null, deterministic: false });
      }
    }
  }

  return snapshots;
}

async function truncateProjectionTables(): Promise<void> {
  console.log('\n--- Truncating projection tables ---');

  const allTables = [...DETERMINISTIC_TABLES, ...NONDETERMINISTIC_TABLES];

  for (const table of allTables) {
    if (PRESERVE_TABLES.includes(table as typeof PRESERVE_TABLES[number])) {
      console.log(`  [SKIP] ${table} (preserved)`);
      continue;
    }

    try {
      await pool.query(`TRUNCATE TABLE ${table} CASCADE`);
      console.log(`  [OK] Truncated ${table}`);
    } catch (err) {
      console.log(`  [WARN] Could not truncate ${table}: ${(err as Error).message}`);
    }
  }
}

async function resetConsumerOffsets(): Promise<string[]> {
  console.log('\n--- Resetting consumer offsets to earliest ---');

  const kafka = new Kafka({
    clientId: 'ox-replay-harness',
    brokers: REDPANDA_BROKERS,
    logLevel: logLevel.NOTHING,
  });

  const admin: Admin = kafka.admin();
  await admin.connect();

  const resetGroups: string[] = [];

  try {
    for (const group of CONSUMER_GROUPS) {
      try {
        // Delete the consumer group to force re-read from beginning
        await admin.deleteGroups([group]);
        console.log(`  [OK] Deleted consumer group ${group}`);
        resetGroups.push(group);
      } catch (err) {
        console.log(`  [WARN] Could not delete group ${group}: ${(err as Error).message}`);
      }

      // Also clear our consumer_offsets table for this group
      try {
        await pool.query(`DELETE FROM consumer_offsets WHERE consumer_group = $1`, [group]);
        console.log(`  [OK] Cleared consumer_offsets for ${group}`);
      } catch {
        // May not exist
      }
    }
  } finally {
    await admin.disconnect();
  }

  return resetGroups;
}

async function seedDeterministicData(): Promise<void> {
  console.log('\n--- Seeding deterministic test data ---');

  // Check if services are available
  try {
    const [agentsHealth, physicsHealth] = await Promise.all([
      fetch(`${AGENTS_URL}/healthz`),
      fetch(`${PHYSICS_URL}/healthz`),
    ]);

    if (!agentsHealth.ok || !physicsHealth.ok) {
      console.log('  [WARN] Services not fully available, skipping seed');
      return;
    }
  } catch (err) {
    console.log(`  [WARN] Could not reach services: ${(err as Error).message}`);
    return;
  }

  // 1. Trigger physics ticks to populate world state
  console.log('  [STEP] Triggering physics ticks...');
  for (const target of ['ox-sandbox', 'ox-lab']) {
    try {
      const res = await fetch(`${PHYSICS_URL}/deployments/${target}/tick`, {
        method: 'POST',
        headers: { 'x-ops-role': 'test' },
      });
      if (res.ok) {
        console.log(`    [OK] Physics tick for ${target}`);
      }
    } catch {
      console.log(`    [WARN] Could not trigger physics tick for ${target}`);
    }
  }

  // 2. Create test agent if needed
  console.log('  [STEP] Ensuring test agent exists...');
  const testAgentId = '00000000-0000-0000-0000-000000000001';
  try {
    // Check if agent exists
    const checkRes = await fetch(`${AGENTS_URL}/agents/${testAgentId}`);
    if (checkRes.status === 404) {
      // Register test agent
      const regRes = await fetch(`${AGENTS_URL}/agents`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          handle: 'replay-test-agent',
          deployment_target: 'ox-sandbox',
        }),
      });
      if (regRes.ok) {
        console.log('    [OK] Created test agent');
      }
    } else {
      console.log('    [OK] Test agent exists');
    }
  } catch (err) {
    console.log(`    [WARN] Could not ensure test agent: ${(err as Error).message}`);
  }

  // 3. Trigger agent action attempts (accepted + rejected)
  console.log('  [STEP] Triggering agent action attempts...');
  const idempotencyBase = 'replay-harness-seed';

  // Action that should be accepted (low cost)
  try {
    const acceptRes = await fetch(`${AGENTS_URL}/agents/${testAgentId}/actions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-idempotency-key': `${idempotencyBase}-accept-1`,
      },
      body: JSON.stringify({
        action_type: 'tool_call',
        requested_cost: 1,
        deployment_target: 'ox-sandbox',
      }),
    });
    if (acceptRes.ok || acceptRes.status === 409) {
      console.log('    [OK] Low-cost action attempt (likely accepted)');
    }
  } catch (err) {
    console.log(`    [WARN] Action attempt failed: ${(err as Error).message}`);
  }

  // Action that might be rejected (high cost)
  try {
    const rejectRes = await fetch(`${AGENTS_URL}/agents/${testAgentId}/actions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-idempotency-key': `${idempotencyBase}-reject-1`,
      },
      body: JSON.stringify({
        action_type: 'cognition',
        requested_cost: 9999,
        deployment_target: 'ox-sandbox',
      }),
    });
    if (rejectRes.ok || rejectRes.status === 409 || rejectRes.status === 402) {
      console.log('    [OK] High-cost action attempt (likely rejected)');
    }
  } catch (err) {
    console.log(`    [WARN] Action attempt failed: ${(err as Error).message}`);
  }

  // Wait for events to propagate
  console.log('  [WAIT] Allowing events to propagate (3s)...');
  await new Promise(resolve => setTimeout(resolve, 3000));
}

async function waitForConsumerToProcess(timeoutMs: number = 60000): Promise<void> {
  console.log('\n--- Waiting for consumers to reprocess events ---');

  const startTime = Date.now();
  let lastWorldCount = -1;
  let lastLiveCount = -1;
  let stableIterations = 0;

  while (Date.now() - startTime < timeoutMs) {
    // Check both world state and live events as proxies
    const [worldRes, liveRes] = await Promise.all([
      pool.query('SELECT count(*) as count FROM ox_world_state'),
      pool.query('SELECT count(*) as count FROM ox_live_events'),
    ]);

    const worldCount = Number(worldRes.rows[0].count);
    const liveCount = Number(liveRes.rows[0].count);

    const elapsed = Math.round((Date.now() - startTime) / 1000);

    if (worldCount === lastWorldCount && liveCount === lastLiveCount) {
      stableIterations++;
      if (stableIterations >= 3 && (worldCount > 0 || liveCount > 0)) {
        console.log(`  [OK] Consumers stable: world=${worldCount}, live=${liveCount}`);
        return;
      }
    } else {
      stableIterations = 0;
    }

    lastWorldCount = worldCount;
    lastLiveCount = liveCount;
    console.log(`  [WAIT] world=${worldCount}, live=${liveCount} (${elapsed}s elapsed)`);

    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  console.log(`  [WARN] Timeout waiting for consumers`);
}

async function restartOxReadService(): Promise<void> {
  console.log('\n--- Restarting OX Read service ---');

  // Kill the existing ox-read process
  try {
    const { exec } = await import('child_process');
    const util = await import('util');
    const execPromise = util.promisify(exec);

    await execPromise('pkill -f "@services/ox-read" 2>/dev/null || true');
    console.log('  [OK] Killed existing ox-read process');

    // Wait a moment
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Start ox-read in background
    exec('pnpm --filter @services/ox-read dev > logs/ox-read.log 2>&1 &');
    console.log('  [OK] Started ox-read service');

    // Wait for it to be ready
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Verify it's running
    const healthRes = await fetch(`${OX_READ_URL}/healthz`);
    if (healthRes.ok) {
      console.log('  [OK] OX Read service is healthy');
    }
  } catch (err) {
    console.log(`  [WARN] Could not restart ox-read: ${(err as Error).message}`);
    console.log('  [INFO] Please manually restart: pnpm --filter @services/ox-read dev');
  }
}

function compareSnapshots(
  before: TableSnapshot[],
  after: TableSnapshot[]
): ReplaySummary['diffs'] {
  const diffs: ReplaySummary['diffs'] = [];

  for (const b of before) {
    // Only compare deterministic tables (unless INCLUDE_NONDETERMINISTIC)
    if (!b.deterministic && !INCLUDE_NONDETERMINISTIC) {
      continue;
    }

    const a = after.find(t => t.table === b.table);
    if (!a) {
      diffs.push({ table: b.table, before: b.count, after: -1, checksum_match: false });
      continue;
    }

    const countMatch = b.count === a.count;
    const checksumMatch = b.checksum === a.checksum;

    if (!countMatch || !checksumMatch) {
      diffs.push({
        table: b.table,
        before: b.count,
        after: a.count,
        checksum_match: checksumMatch,
      });
    }
  }

  return diffs;
}

async function runReplay(): Promise<ReplaySummary> {
  const startTime = Date.now();

  console.log('='.repeat(60));
  console.log('OX Read Replay Harness');
  console.log('='.repeat(60));
  console.log(`\nConfiguration:`);
  console.log(`  INCLUDE_NONDETERMINISTIC: ${INCLUDE_NONDETERMINISTIC}`);
  console.log(`  SKIP_SEED: ${SKIP_SEED}`);
  console.log(`  Deterministic tables: ${DETERMINISTIC_TABLES.length}`);
  console.log(`  Nondeterministic tables: ${NONDETERMINISTIC_TABLES.length}`);

  // Step 0: Seed deterministic data (unless skipped)
  if (!SKIP_SEED) {
    await seedDeterministicData();
  } else {
    console.log('\n--- Skipping seed step (REPLAY_SKIP_SEED=1) ---');
  }

  // Step 1: Snapshot before
  console.log('\n--- Snapshotting current state (BEFORE) ---');
  const before = await snapshotAllTables();
  for (const s of before) {
    if (s.count >= 0) {
      const tag = s.deterministic ? '' : ' [non-deterministic]';
      console.log(`  ${s.table}: ${s.count} rows (checksum: ${s.checksum ?? 'n/a'})${tag}`);
    }
  }

  // Step 2: Truncate projection tables
  await truncateProjectionTables();

  // Step 3: Reset consumer offsets
  const resetGroups = await resetConsumerOffsets();

  // Step 4: Restart ox-read service (to restart consumers)
  await restartOxReadService();

  // Step 5: Wait for consumers to reprocess
  await waitForConsumerToProcess(90000);

  // Step 6: Snapshot after
  console.log('\n--- Snapshotting replayed state (AFTER) ---');
  const after = await snapshotAllTables();
  for (const s of after) {
    if (s.count >= 0) {
      const tag = s.deterministic ? '' : ' [non-deterministic]';
      console.log(`  ${s.table}: ${s.count} rows (checksum: ${s.checksum ?? 'n/a'})${tag}`);
    }
  }

  // Step 7: Compare
  console.log('\n--- Comparing snapshots ---');
  const diffs = compareSnapshots(before, after);

  const duration_ms = Date.now() - startTime;
  const pass = diffs.length === 0;

  const summary: ReplaySummary = {
    compared_tables: before.filter(t => t.deterministic || INCLUDE_NONDETERMINISTIC).map(t => t.table),
    excluded_tables: INCLUDE_NONDETERMINISTIC ? [] : [...NONDETERMINISTIC_TABLES],
    topics_replayed: [...TOPICS],
    consumer_groups_reset: resetGroups,
    pass,
    diffs,
    duration_ms,
  };

  // Print summary
  console.log('\n' + '='.repeat(60));
  if (pass) {
    console.log('REPLAY SUCCESS: All projections are deterministic');
  } else {
    console.log('REPLAY FAILED: Projections differ');
  }
  console.log('='.repeat(60));

  console.log('\n--- Summary ---');
  console.log(`  compared_tables: [${summary.compared_tables.join(', ')}]`);
  console.log(`  excluded_tables: [${summary.excluded_tables.join(', ')}]`);
  console.log(`  topics_replayed: [${summary.topics_replayed.join(', ')}]`);
  console.log(`  consumer_groups_reset: [${summary.consumer_groups_reset.join(', ')}]`);
  console.log(`  pass: ${pass}`);
  console.log(`  duration_ms: ${duration_ms}`);

  if (diffs.length > 0) {
    console.log('\n--- Differences ---');
    for (const d of diffs) {
      const checksumNote = d.checksum_match ? '' : ' (checksum mismatch)';
      console.log(`  ${d.table}: ${d.before} -> ${d.after} (delta: ${d.after - d.before})${checksumNote}`);
    }
  }

  return summary;
}

async function main() {
  try {
    const result = await runReplay();

    // Output JSON if requested
    if (process.env.OX_REPLAY_JSON_OUTPUT) {
      console.log('\n--- JSON Output ---');
      console.log(JSON.stringify(result, null, 2));
    }

    await pool.end();
    process.exit(result.pass ? 0 : 1);
  } catch (err) {
    console.error('\nREPLAY ERROR:', err);
    await pool.end();
    process.exit(1);
  }
}

main();
