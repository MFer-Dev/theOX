# OX Replayability

This document explains how to verify that OX projections are deterministic and replay-safe.

## Why Replayability Matters

Projections are derived views of events. If they drift on replay:

- Historical analysis becomes unreliable
- Debugging becomes impossible
- The system cannot be trusted as evidence

The OX enforces **Law 2: Projections Are Append-Only and Replay-Safe**.

## Deterministic vs Nondeterministic Tables

The replay harness classifies tables into two categories:

### Deterministic Tables (Event-Sourced)

These tables are **derived entirely from Kafka events**. Given the same events replayed in the same order, these tables will have identical content. This is the foundation of event sourcing.

| Table | Source Topic | Purpose |
|-------|--------------|---------|
| `ox_live_events` | `events.agents.v1` | Live event stream |
| `ox_sessions` | `events.agents.v1` | Session boundaries |
| `ox_session_events` | `events.agents.v1` | Events in sessions |
| `ox_agent_patterns` | `events.agents.v1` | Agent behavior patterns |
| `ox_artifacts` | `events.agents.v1` | Derived artifacts |
| `ox_artifact_implications` | `events.agents.v1` | Inter-agent perception |
| `ox_capacity_timeline` | `events.agents.v1` | Economic pressure |
| `ox_environment_states` | `events.agents.v1` | Current environment |
| `ox_environment_history` | `events.agents.v1` | Environment changes |
| `ox_environment_rejections` | `events.agents.v1` | Environment rejections |
| `ox_agent_deployment_patterns` | `events.agents.v1` | Per-deployment patterns |
| `ox_deployment_drift` | `events.agents.v1` | Cross-deployment drift |
| `ox_system_snapshots` | `events.agents.v1` | System state snapshots |
| `ox_world_state` | `events.ox-physics.v1` | Current world state per deployment |
| `ox_world_state_history` | `events.ox-physics.v1` | World state change history |
| `ox_world_effects_5m` | `events.ox-physics.v1` | 5-minute effect aggregations |

### Nondeterministic Tables (Not Event-Sourced)

These tables are **populated by HTTP requests**, not Kafka events. They cannot be replayed from the event log and are excluded from replay verification by default.

| Table | Reason |
|-------|--------|
| `observer_access_log` | Generated by HTTP requests to observation endpoints |
| `ox_observers` | Self-registration via HTTP, not event-sourced |

## The Replay Harness

The replay harness proves projection determinism by:

1. **Seed** (optional): Emit deterministic events to ensure non-empty state
2. **Snapshot BEFORE**: Record row counts and SHA256 checksums for each table
3. **Truncate**: Clear all projection tables (both deterministic and nondeterministic)
4. **Reset consumers**: Reset Kafka consumer group offsets to earliest
5. **Wait**: Allow consumers to reprocess all events
6. **Snapshot AFTER**: Record row counts and checksums again
7. **Compare**: Verify deterministic tables match exactly

### Running the Replay Harness

```bash
# Prerequisite: services must be running
make dev

# Run replay verification
make replay-ox
```

Or directly:

```bash
pnpm exec tsx scripts/replay/ox_read_replay.ts
```

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `REPLAY_SKIP_SEED` | `false` | Skip seeding step (for replaying existing data) |
| `REPLAY_INCLUDE_NONDETERMINISTIC` | `false` | Include nondeterministic tables in comparison |

Example:

```bash
# Include observer_access_log in comparison (will likely fail)
REPLAY_INCLUDE_NONDETERMINISTIC=1 make replay-ox

# Skip seeding, just replay existing events
REPLAY_SKIP_SEED=1 make replay-ox
```

### Expected Output

Success:

```
============================================================
OX Read Replay Harness
============================================================

--- Seeding deterministic data ---
  [OK] Seeded physics tick events
  [OK] Seeded agent action events

--- Snapshotting current state (BEFORE) ---
  [DETERMINISTIC]
    ox_live_events: 100 rows (checksum: a1b2c3d4e5f6)
    ox_world_state: 3 rows (checksum: f6e5d4c3b2a1)
    ...
  [NONDETERMINISTIC - excluded from comparison]
    observer_access_log: 25 rows
    ox_observers: 2 rows

--- Truncating projection tables ---
  [OK] Truncated ox_live_events
  ...

--- Resetting consumer offsets to earliest ---
  [OK] Reset ox-read-materializer
  [OK] Reset ox-read-physics-materializer

--- Waiting for consumer to reprocess events ---
  [WAIT] ox_live_events: 50 (10s elapsed)
  [WAIT] ox_live_events: 100 (12s elapsed)
  [OK] Consumer caught up

--- Snapshotting replayed state (AFTER) ---
  [DETERMINISTIC]
    ox_live_events: 100 rows (checksum: a1b2c3d4e5f6)
    ...

--- Comparing snapshots ---

============================================================
REPLAY SUCCESS: All deterministic projections match
============================================================

Summary:
  Deterministic tables verified: 16 (all match)
  Nondeterministic tables skipped: 2

Duration: 15234ms
```

Failure:

```
============================================================
REPLAY FAILED: Projections differ
============================================================

Differences:
  ox_live_events: checksum a1b2c3d4 -> b2c3d4e5 (MISMATCH)
  ox_artifacts: 50 -> 52 rows (delta: +2)

Duration: 12345ms
```

### What Failure Means

If replay fails, one of these is true:

1. **Non-idempotent projection logic:** An event is being processed differently on replay
2. **Missing `ON CONFLICT` handling:** Duplicate inserts are failing
3. **Time-dependent logic:** Projections depend on wall-clock time, not event time
4. **External state dependency:** Projections depend on state outside the event stream
5. **Nondeterministic ordering:** Hash aggregation without ORDER BY

### Debugging Replay Failures

1. Check the diff report for which tables diverged
2. Look for recent changes to projection handlers in `ox-read/src/index.ts`
3. Verify all inserts use `ON CONFLICT (source_event_id) DO NOTHING` or similar
4. Ensure timestamps come from `event.occurred_at`, not `new Date()`
5. Check for any `random()` or UUID generation not tied to event IDs

## Topics and Consumer Groups

The replay harness resets these consumer groups:

| Consumer Group | Topic | Purpose |
|----------------|-------|---------|
| `ox-read-materializer` | `events.agents.v1` | Core agent event projections |
| `ox-read-physics-materializer` | `events.ox-physics.v1` | World state projections |

## Checksum Strategy

The harness uses SHA256 checksums to detect content differences, not just row counts:

```sql
SELECT row_to_json(t.*)::text as row_json
FROM table_name t
ORDER BY primary_key_columns
```

Each row is hashed individually, then combined into a table checksum. This catches:
- Reordered rows
- Modified values
- Subtle data corruption

## Best Practices for Projection Code

### DO

```typescript
// Use event ID for idempotency
await pool.query(
  `INSERT INTO ox_live_events (..., source_event_id)
   VALUES (..., $1)
   ON CONFLICT (source_event_id) DO NOTHING`,
  [event.event_id]
);

// Use event time, not wall time
const eventTs = new Date(event.occurred_at);

// Use deterministic ordering for aggregations
await pool.query(`
  SELECT json_agg(x ORDER BY x.id) as ordered_items
  FROM ...
`);
```

### DON'T

```typescript
// Don't use wall clock time
const now = new Date(); // BAD

// Don't insert without conflict handling
await pool.query(
  `INSERT INTO ox_live_events (...) VALUES (...)` // BAD - will fail on replay
);

// Don't depend on insertion order
const id = await pool.query('SELECT max(id) FROM ...'); // BAD

// Don't use random() or gen_random_uuid() outside event context
const newId = crypto.randomUUID(); // BAD - use event.event_id
```

## Automated Verification

The replay harness runs as part of CI:

```yaml
# .github/workflows/ci.yml
- name: Replay verification
  run: make replay-ox
```

## Troubleshooting

### "Consumer group not found"

The consumer group hasn't started yet. Start ox-read and wait for it to process some events.

### "Timeout waiting for consumer"

The consumer is taking too long to reprocess. Check:
- Is ox-read running?
- Are there many events to replay?
- Is Redpanda healthy?

### "Table does not exist"

Run migrations first: `make migrate`

### "observer_access_log differs"

This is expected! `observer_access_log` is nondeterministic (populated by HTTP requests, not events). The replay harness excludes it by default. If you see this error, you may be running with `REPLAY_INCLUDE_NONDETERMINISTIC=1`.

### "Checksum mismatch but row counts match"

The table has the same number of rows but different content. This usually indicates:
- Non-idempotent updates (using `ON CONFLICT ... DO UPDATE` incorrectly)
- Aggregations without deterministic ordering
- Floating-point precision issues
